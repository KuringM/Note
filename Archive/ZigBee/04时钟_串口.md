# 时钟
## 一些概念
1. cc2530在正常运行的时候需要一个高频时钟信号和一个低频的时钟信号<BR>
高频时钟信号, 主要供给CPU, 保证程序的运行.<BR>
低频时钟信号, 主要供给看门狗, 睡眠定时器等片上外设.
2. 时钟信号的来源<BR>
高频信号有2个, 芯片内部的16M RC电路; 外接的32M石英晶振.<BR>
低频信号也有2个来源, 芯片内部的32K RC电路, 外接的32.768K石英晶振<BR>
3. cc2530芯片默认上电的时候,是内部的2个RC电路作为高频和低频的时钟来源<BR>
4. 如果我们在用串口, 特别是无线通信的时候, 必须要用32M的石英晶振作为高频时钟来源<BR>
5. 时钟源特点:<BR>
2个高频时钟源可以起振同时产生高频时钟信号<BR>
而2个低频时钟源, 某一时刻只能有1个起振, 并且起振的这个时钟源供给cc2530

## 系统高频时钟源切换步骤
1. 让2个高频时钟源起振
2. 等待目标时钟源振荡稳定
3. 延时一小段时间63us
4. 不分频输出
5. 选中目标高频时钟源作为系统主时钟
6. 确认一下当前工作的系统时钟是不是所选的高频时钟

> 相关寄存器:SLEEPCMD, SLEEPSTA, CLKCONCMD, CLKCONSTA

1. 让SLEEPCMED的第二位为0
2. SLEEPSTA寄存器的第6位为1表示32M时钟源稳定
3. 超过63us延时
4. 把寄存器CLKCONCMD的低3位设置为000, 表示不分频输出
5. 包寄存器CLKCONCMD的第6位清0, 设置32M作为系统主时钟
6. 如果读CLKCONSTA这个寄存器的第6位为0, 表示32M的时钟源已经作为当前的系统主时钟, 程序可以往下运行了.

``` c
void delayus()
{
	char k=63;
	while(k--);
}
void Init32M()
{
	SLEEPCMD &= 0xfb; //1111 1011 开启2个高频时钟源
	while(0==(SLEEPSTA & 0x40)); //0100 0000 等待32M稳定
	delayus();
	CLKCONCMD &= 0xf8; //1111 1000 不分频输出
	CLKCONCMD &= 0xbf; //1011 1111 设置32M作为系统主时钟
	while(CLKCONSTA & 0x40); //0100 0000 等待32M成功成为系统主时钟

}
```

# 串口
##  串口配置步骤
1. 指定串口的IO位置
2. 相应IO配置成片上外设功能
3. 8个数据为、1个停止为、无流控、无效验确立
4. 波特率
5. 开CPU中断、对应串口接收中断

``` c
#include <iocc2530.h>
void Cfg32M()
{
	SLEEPCMD &= 0xfb; //1111 1011 开启2个高频时钟源
	while(0==(SLEEPSTA & 0x40)); //0100 0000 等待32M稳定
	CLKCONCMD &= 0xf8; //1111 1000 不分频输出

	CLKCONCMD &= 0xbf; //1011 1111 设置32M作为系统主时钟
	while(1==(CLKCONSTA & 0x40)); //0100 0000 如果32M确认供给CPU在工作, 那么程序往下执行
	SLEEPCMD |= 0x40;
}
void Uart0Cfg()
{
	PERCFG &= ~0x01; // 选中串口0的备用位置1
	P0SEL |= 0x0c; // 0000 1100 P0_2 P0_3为片上外设

	U0CSR |= 0xc0;

	// 波特率
	U0GCR = 11;
	U0BAUD = 216;

	//开中断
	URX0IE = 1;
	EA = 1;
}

void main()
{
	Cfg32M();//如果我们在用串口, 特别是无线通信的时候, 必须要用32M的石英晶振作为高频时钟来源
	Uart0Cfg();
	while(1);
}


#pragma vector=URX0_VECTOR
__interrupt void sdfs(void)
{
	char ch;
	URX0IF=0; // 串口0来数据的标志位, 硬件会置1, 我们要在软件中清0
	ch=U0DBUF; //	从接受寄存器里取字节存入变量ch

	U0DBUF=ch; // 把变量ch里的值赋给串口0发送数据寄存器
	while(0==UTX0IF); // 等待传送完
	UTX0IF=0;
}
```

